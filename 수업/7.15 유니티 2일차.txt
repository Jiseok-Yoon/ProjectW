페이즈별 로드

Input = 유니티에서 지원하는 입력 지원 클래스
GetKeyDown(KeyCode.Return) 엔터 눌렸을 때.

모든 페이즈 로드 후 엔터 누르면 씬 변경.

씬 변경하려면 게임 매니저의 로드 씬 불러야 함.
빈 객체만들어 게임 매니저 컴포넌트 붙일 수 있음.
타이틀 컨트롤러도 빈 객체 하나 만들어서 붙여주기.

그럼 이제 객체 참조 어떻게 가져오나?

유니티에서 기본적으로 타 객체 참조 받는 방법.
모노 비해비어 상속받는 객체에서 퍼블릭으로 참조받고자 하는 다른 모노 클래스를 작성하면 됨.

퍼블릭 객체는 인스펙터에서 노출이 되니까 거기에 가서 넣어주면 참조를 받을 수 있음.
여러 객체에서 다발적인 참조가 필요하지 않으면 이렇게 퍼블리 필드로 객체 받아서 사용하는 경우가 많음.
문제점은 우리가 사용하고자 하는 게임 매니저는 타 클래스에서도 이객체 가져다 쓸 일이 많다는 것.
그 때마다 모든 곳에서 퍼블릭 필드로 작성할 수 없음.

그래서 싱글톤으로 만들 것. 객체의 인스턴스를 딱 하나만 존재하게 만드는 것.
Singleton

유틸 폴더 만들어서 Singleton 파일 클래스 생성.
싱글톤 구현 위한 클래스.

FindObjectOfType = 유니티에서 씬에서 객체 찾는 메소드.
var obj = new GameObject(typeof(T).Name); T형식의 이름으로 오브젝트 생성.
AddComponent = 오브젝트에 있는 컴포넌트 추가 메소드.

protected virtual void Awake() = Awake() 는 유니티 콜백 함수. 객체 초기화 시 호출.
DontDestroyOnLoad(gameObject); = 씬이 변경되어도 해당 오브젝트는 파괴되지 않음.

스크립트는 순서 안정하면 랜덤 순서로 돌아감. 그런데 그 전에 다른 클래스에서 싱글톤 객체 접근하면 프로퍼티 통해서 접근함. 씬에 다른 애가 있는데 초기화가 안되었을 때 접근하면 씬이 인스턴스가 없다고 판별해서 새로운 객체 생성해버림. 이렇게 되면 하이라키에 같은 게임 오브젝트가 두개가 생성됨.

// 우리가 사용하는 싱글톤은 무조건 미리 씬에 싱글톤 객체를 배치한다고 가정하고 사용

싱글톤 남발하면 호출해서 사용하는 곳들의 결합 생각해서 잘 안짜주면 스파게티 코드가 되서 관리가 힘듦.
커플링 디커플링 잘 생각해야 함.

로고에 간단한 애니메이션.

로고에 컴포넌트 추가. 애니메이터사용할 것.

애니메이션과 애니메이터의 차이 : 애니메이션 컴포넌트는 간단하게 애니메이션 클립. 애니메이션 데이터 들어있는 소스 받아서 재생시키는 것. 여러개 받을 것이면 애니메이션즈에 숫자 넣어주고 바꿔가면서 재생 가능. 그런데 일바적으로 잘 안씀. 애니메이션으로 실행할 수 있는 것은 유니티에서 만들어진 간단한 애니메이션 같은 건 가능한데 유니티에서 만들어진 애니메이션 파일이 아니면 정상적으로 실행시킬 수가 없음. 복잡한 애니메이션 파일은 실행을 정상적으로 실행시킬 수 없음. 외부에서 다른 애니메이터가 만든 복잡한 애니메이터 파일같은 것을 실행시키려면 애니메이터 사용해야 함.
애니메이터는 여러가지 애니메이션을 가지고 사용자가 설정한 상태나 변수에 따라서 이 애니메이션에서 다른 애니메이션으로 트랜지션이나 변경되면서 자연스럽게 블렌딩 해주거나.

애니메이터는 컨트롤러가 제일 중요. 프로젝트에서 컨트롤러를 만들어서 이 안에 내가 제어하고자 하는 애니메이션들 추가가 가능. 

프로젝트 애셋 폴더에 Anim 폴더 생성.
크리에이트-애니메이터컨트롤러.

윈도우 - 애니메이션 - 애니메이터 누르면 에디터 창 열림.
애니메이션 생성은 윈도우 - 애니메이션 - 애니메이션

크리에이트 - Animation

애니메이션에서 우리가 만든 애니메이션을 게임 객체에 할당해주면 애드 프로퍼티 통해서 값들 조절 가능.

LogoAnim 애니메이터에 끌어다 이동. 이동은 알트키 누르고 이동.

기본 3가지 엔트리, 애니 스테이트, 익싯.
엔트리 노드에서 시작. 자동으로 내가 끌어다 놓은 로고 애님쪽으로 노란 선이 생김. 노란 선은 기본 디폴트 트랜지션. 트랜지션이 연결되어 있어야만 노드간 이동이 가능.

무조건 로고 애님 실행하게 하고 컨트롤러 애니메이터 컴포넌트에서 할당.

할당해주면 애니메이션에서 애드 프로퍼티 가능.
렉트 트랜스폼에서 앵커드 포지션 수정해서 떠다니게.
프로퍼티 추가하고 타임라인 같은 곳에서 다이아몬드가 추가됨. 이것들은 같은줄에 있는 필드를 의미.
가장 상단에 있는 아무것도 없는 필드는 아래 모든 다이아를 포함하는 전체버튼 같은 것.
이 버튼을 추가해서 컨트롤할 수 있음. 다이아가 없는 구간은 이전 다이아 값에서 다음 다이아 값으로 값이 선형 보간됨.

우리는 맨 끝 다이아 선택해서 끌고오기.
타임 그래프는 프레임임. 흰색 실선 왼쪽ㅇ ㅣ프레임.
실선 가지고 가서 애드 키프레임 아이콘 눌러주면 다이아 생김.

그런데 재생하면 한번하고 끝남. 애니메이터에서 한 번 하고 멈춤 루프안함.
추가적으로 루프시켜줘야 함.

루프는 프로젝트에서 애니메이션 클립 누르면 인스펙터에 루프타임이라고 있음.

인게임 씬에선 빈객체 만들고 백그라운드. 거기에 스프라이트 렌더러 컴포넌트 추가.
이거 이용해서 출력할 것. 왜 얘 사용하냐면 UI에선 캔버스를 씀.
캔버스 아래에 이미지 개체가 있고 활성화 비활성화 될 때 혹은 UI객체 이동, 순서 바뀌는 경우 모두에 캔버스 지우고 다시 쓰는 작업이 일어남. 그래서 움직임이 많은 개체는 캔버스 UI로 처리할게 아니라 스프라이트 렌더러로 처리함.
배경과 플레이어 그러니 스프라이트 렌더러로.
대신 풀편한 점은 화면에 맞추거나 이런 부분 귀찮음. 그래서 렌더러 따라 리사이즈 해주는 코드들 필요함.

인게임에서 이제 백그라운드랑 플레이어 가져오기.
스프라이트 멀티로 쪼개기

스프라이트 쪼갤 때 이미지 흰색이라 알기 어려우면 어플라이 옆에 rgb 눌러서 흑백으로 보거나 컨트롤 누르면 녹색됨.

위치 000하고 스프라이트 렌더러 하면 안보일 수 있음. 순서가 있어서.
렌더러 하단에 애디셔널 셋팅에 소팅 레이어 있음.
레이어는 필요하면 나누고 지금 우리에게 필요한 건 오더 인 레이어에서 플레이어를 1로 올리면 됨.
플레이어에 빈객체 추가해서 셰도우 넣기
마찬가지로 스프라이트 렌더러 넣고 색깔 바꾸기.
자식은 참고로 부모 위치 따라감.

Player 스크립트 만들기. 이동하기 위해.
Input.GetAxisRaw("Horizontal")

파일에 빌드셋팅에 왼쪽하단 플레이어 세팅누르면 프로젝트 세팅 창이 뜸. 이 프로젝트 셋팅은 인스펙터 쪽에 두는게 좋음.
이탭에 인풋매니저라는 탭이 있음.
여기에 기본적으로 자주 쓰는 키가 이미 바인딩 되어있음.

이거 쓰면 왼쪽 -1 가만히 0 오른쪽 1 반환.

이거 Vector2 direction 에 저장.
그리고 캐릭터 이동속력.곱해서 속도 얻을 수 있음.



