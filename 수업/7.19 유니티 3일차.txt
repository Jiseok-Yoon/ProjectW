transform.Translate() 통해 이동 가능.
업데이트는 매 프레임 호출. 근데 컴퓨터별로프레임이 다르면 업데이트가 호출되는 횟수가 달라짐.
        // ex) 프레임이 70이 나오는 컴퓨터에서 70번 호출
        // 프레임이 30이 나오는 컴퓨터에서 30번 호출
        // 결과적으로, 최종적으로 이동한 거리가 pc마다 달라지게 됨..
        // 그러지 않기 위해 Time.deltaTime 곱함

이동 제한 걸기
빈 객체 만들어서 w 눌러 기즈모 이동으로 바꾸고 끝부분에 배치
플레이어 캐릭터에서 트랜스폼 두개 선언.
이프문 두개 걸어서 변환.
그리고 작성했으니 참조 끌어넣기.

물고기랑 쓰레기 실행시간에 만들어져야 함.
그리고 얘들하고 플레이어랑 충돌을 확인해야 함. 그러니 박스 콜라이더 추가.
박스 콜라이더 2D넣기. 넣으면 그리고 물고기 객체 주변에 초록색으로 기즈모가 생김. 그 영역만큼이 충돌영역임.
이 영역을 수정하려면 박스 콜라이더에서 수정해야하는데 씬에서 직접 수정하려면 에딧 콜라이더에 버튼 누르면 초록색 기즈모에 크기 조절 옵션이 생김.
우리가 원하는건 충돌하면 멈추는게 아니라 없어지고 먹어서 물고기 없애주는 것.
즉 플레이어랑 좀 겹쳐야 함. 이 겹침을 확인하려고 할 때 콜라이더에서 이스 트리거 체크.

그리고 드롭 오브젝트 스크립트 생성.
그리고 쓰레기와 물고기 구분해줄 에넘타입 선언.
그리고 떨이지는 속도와 돌아가는 속도 등.
그리고 플레이어 객체 대한 참조.

        transform.Translate(Vector3.down * fallSpeed * Time.deltaTime, Space.World);
이동작업. Space 안에 self와 world 두개 있음. 자기 자신 기준으로 움직일건지 월드공간 기준으로 움직일건지.
기본값은 셀프.

그리고 객체 y 포지션 특정 이하로 내려가면 삭제해줘야 함. 그런데 이걸 포지션 숫자로 넣고 삭제해주면 문제의 소지가 많음.

OnBecameInvisible
카메라에서 렌더러가 더이상 표시되지 않으면 한 번 호출

스프라이트 렌더러가 화면 밖으로 넘어가면 자동으로 호출되는 유니티의 콜백함수.

이제 회전. 트랜스폼에서 우리가 보듯이 벡터로 사용하는게 오일러 앵글.

        // transform.eulerAngles -> 인스펙터 화면에 보이는 대로 Vector3 형태로 사용

        // 오일러 앵글 사용 시 특정 상황에서 짐벌락 문제가 발생할 수 있음
        // 추가로, 사원수(쿼터니언)을 이용한 연산이 오일러 앵글을 이용한 연산보다 훨씬 빠름

콜라이더에 이스 트리거 체크되면 OnTrigger 메소드들이 있음. 2D 달린거 있고 안달린거 있음. 안달린게 3D용

트리거 쓰는 애들은 트리거 쓰고 일반 충돌은 OnCollisionEnter, OnCollisionStay, OnCollisionExit 씀

이제 콜라이더에 들어오면 플레이어인지 확인해야 함.
태그를 이용해서 판별.

if (collision.CompareTag("Player"))

라이프랑 점수 바꾸는 메소드 구현
점수는 게임 매니저에서 들고 있을 것.

점수 -안되게 Mathf.Max(0, currentScore + addScore);
Mathf 유니티에서 수학 기능 제공. 맥스는 둘 중 큰 값 반환.

이제 객체 동적 생성하려면 유니티에서 지원하는 Prefab 파일로 만들어야 함.
그냥 끌어다가 프로젝트에 넣으면 Prefab 생성됨.

원형 객체가 되고 이거 가지고 인스턴스 만드는 것.
이제 만들어줄 스포너 스크립트 생성

Instantiate -> 객체 생성 메소드. 유니티의 오브젝트. 프리팹.

스포너 객체 만들어서 넣어줌.

