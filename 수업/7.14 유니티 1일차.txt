유니티 허브 프로젝트 생성
2D - 기본 2D 패키지 설치된 템플릿
3D - 기본 3D

3D 생성하면 2D 몇개 없는데 유니티 패키지 매니저 통해서 추가적인 기능 다운받거나 뺄 수 있음.

밑에 HD RP랑 URP는 사용자 원하는대로 렌더링 환경 커스터마이징하는 템플릿.
유니버셜 렌더 파이프라인은 모바일에서 많이 쓰고 그거 경량화 시켜서 모바일 최적화 렌더링 뽑기로 많이 씀.
하이 데피니션은 고퀄 뽑기 위해서 사용 많이 함.
유니버셜 까지는 쓰는 회사 있는데 하이 데피니션은 유니티로 AAA급 만들거 아니면 사용안함. 기본 렌더 세팅도 일반 프로그래밍 지식으로 택도 없음. 그래픽스 지식 있어야 함.

2D생성.

유니티 UI 설명
Scene

씬에서 게임 배치할 객체들 올려두거나 런타임 때 생성한 객체를 씬에 올리면 최종적으로 게임 뷰에서 모습 확인 가능. 씬은 미리 보여주고자 하는 객체 배치하거나 런타임 생성 개체 배치할 때 씬에 올라감.

앞으로 객체 배치하는 공간은 월드라고 함. 그 월드가 씬에 보이게 되는 것. 월드에 배치한 객체 출력하면 게임 뷰에 표시.

Game

하이어러키 가면 기본 카메라 있는데 카메라가 찍는 화면이 게임 뷰에 나오게 됨.

Hierarchy

기본으로 메인 카메라 있음.
내가 생성한 객체들이 나올 것. 제일 상단에 보면 SampleScene이 있음.
유니티에서는 객체를 씬단위로 관리함. 게임은 씬단위로 관리.
게임 킬 때 타이틀 화면. 메뉴 화면. 인게임 화면. 게임의 규모에 따라 인게임에서 씬이 많이 나눠질 수도 있음. 이렇게 씬단위로 게임을 관리함. 씬단위로 관리하는 이유는 타이틀에서 사용할 리소스, 데이터는 타이틀에서만 존재하고 메인은 메인에서만 인게임은 인게임만 존재하게 하려고 관리하는 것. 해당씬에 필요한 것만 들고 있으려고.
자연히 씬 넘어가면 파괴됨.

Inspector

내가 현재 선택한 데이터의 상세 정보를 확인할 수 있는 공간. 비단 하이어러키 뿐만 아니라 프로젝트 탭도.

Console

디버그 용도로 사용. 로직의 흐름이나 버그 확인.


애셋 가져오기. 애셋 안에 . 거기 안에 기본 Scenes 파일이 있음.
우클릭 해서 Create 해서 씬. 타이틀로 작성.

이번 만들 게임은 씬을 두가지로 구성할 것.

타이틀은 

유니티에선 UI 배치하는 별도의 좌표체계가 따로 존재. 우리가 생각하는 플레이어나 몬스터나 이런 인게임 객체들이 존재하는 공간은 월드. 유저가 접하는 인터페이스나 타이틀 화면 인런 것들은 보통 UI 스크린 좌표체계에서 처리를 많이 함. 굳이 월드로 만들어서 처리할 수는 있는데 좌표체계때문에 문제가 되는게 있음.
분류해서 처리하는 것은 UI가 만든 객체들은 좋은 점이 게임의 해상도는 기기에 따라 항상 바뀜. 핸드폰마다 해상도 다 틀린데 그걸 어떻게 동적으로 맞추냐면 기능을 구현해놨기 때문.
무조건 편하다고 다 UI로 하면 안됨.

UI 객체 위해서는 캔버스가 항상 필요함. 도화지 개념. 하이어러키 탭에서 우클릭 해서 UI 탭에서 생성.

캔버스 눌러보면 크게 4가지 나눠짐.
유니티는 객체에 기능들을 하나씩 추가할 수 있음. 이 기능을 컴포넌트라고 표현함. 유니티는 기능 단위로 분류.
객체에 내가 필요한 기능을 이렇게 추가하는데 그걸 컴포넌트라고 함. 캔버스에는 기본 4가지 컨포넌트. 그 중 RectTransform

우클릭해서 create Empty해도 트랜스폼은 있음. 기본적으로 포지션 로테이션 스케일 있음.
어느 위치에 존재하는지 하나의 벡터로. 

유니티 좌표계는 기본 왼손 좌표계. 마우스에 왼손 갖다대보면 중지 x 검지 z 엄지 y

렉트 트랜스 폼은 기본 트랜스 폼과 좌표 체계가 다름. 여기의 포지션 값이 트랜스폼의 포지션이랑 다름.
모든 UI 개체는 렉트 트랜스폼 기본사용.
                                                                                                                                            추가적으로 다른 컴포넌트 보면 캔버스 컴포넌트가 있는데 제일 중요한 것은 렌더 모드.
이 캔버스를 어떤 방식으로 그릴 것인지. 눌렀을 때 크게 3가지 있음. 오버레이, 카메라, 월드스페이스.
오버레이는 화면 전체를 덮어서 출력. 카메라는 특정 카메라를 기준으로. 내가 지정할 수 있음. 그래서 그 카메라 기준으로 렌더. 동일한 것은 얘 둘다 별도의 좌표체계 사용.
마지막 월드스페이스는 월드 공간에 표시해야하는 UI가 가끔씩 있음. MMORPG 보면 몬스터 위에 있는 HP바 등

우리는 기본적으로 오버레이 사용.

그다음 캔버스 스케일러.
이 친구는 캔버스의 크기 조절을 어떻게 할것인지. 기본은 컨스턴트 픽셀 사이즈 고정 픽셀 사이즈로. 거의 사용 안함. UI를 고정된 픽셀 사이즈로 하면 불편하기 때문.거의 사용하지 않음.

그리고 스케일 위드 스크린 사이즈를 가장 많이 씀. 컨스탄트 피지컬 사이즈도 있긴 함.
스케일 위드 스크린 사이즈는 레퍼런스 레졸루션으로 내가 UI 배치시킬 기준 해상도를 작성을 함. 아트 팀에서 UI를 받으면 기준 사이즈 있음.

스크린 매치 모드는 Match Width or Height 매치를 가로로 할지 세로로 할지 선택 가능. 혹은 extend는 확장 개념. 늘려서 맞춤. shrink는 자주 사용은 안함. 

그리고 그래픽 레이캐스터는 UI 상호작용 처리.
유저가 UI 버튼 클릭하거나 하는 행위 할 때 그래픽 레이 캐스터가 존재해야만 상호작용을 할 수 있음.
이벤트 시스템도 UI 만들면 기본적으로 생기는데 그래픽 레이 캐스터 같이 내가 마우스 어딨는지 클릭했는지 아닌 지 이런 정보가 있어서 레이캐스터로 전달해줌.
이벤트 시스템 없으면 당연히 상호작용 못함.

캔버스에 이미지 만들고 이미지 컴포넌트 통해서 내가 원하는 이미지 출력.
소스 이미지 부분에 내가 원하는 이미지를 넣어주면 됨.
처음에는 None (Sprite) 이렇게 표시됨. 들어갈 데이터 형식을 표현해줌. Sprite 형식 넣으면 된다고.
이미지는 동그란 아이콘 눌러서 스프라이트 선택 창이 나옴.

이미지 출력 기준 사이즈는 렉트 트랜스폼의 위드헤잇 기준으로 나옴.
그런데 원하는 사이즈는 직접 입력보다는 캔버스에서 이미 잡아놨기 때문에 유니티에서 지원하는 앵커 기능이 있음. 
렉트 트랜스폼에. 앵커 프리셋을 이용해서 이미지 맞추는게 가장 베스트.
앵커에서 이미지 늘리거나 줄이는 건 stretch
앵커는 하이어러키 상의 부모를 기준으로 함. 이미지는 캔버스 기준으로.

이미지는 바로 넣을 수 없음. 이미지 파일 가져왔을 때 텍스쳐 타입이 Sprite가 아니라 Default로 되어있음.

유니티에서 Texture라는 타입으로 인식하기 때문에 바로 이미지 끌어다 설정할 수 없고 스프라이트로 바꿔줘야 함.

씬에서 보이는 프로그래머에게 가이드, 도움을 주기 위해 표현되는 이미지. 앵커 나오는 것과 같은 것을 Gizmo라고 표현.

로고 앵커 기즈모는 가운데 상단으로 잡힘.
이미지에서 셋 네이티브 사이즈 하면 원본 크기 로 바꿔줌.

이미지 중심점은 pivot 필드를 통해 이미지 자체 기준점을 바꿀 수 있음.
유니티 스크린 좌표 체계는 왼쪽 하단이 00 오른쪽 상단이 11

이미지 파일 나눠쓰는 방법. Sprite 텍스쳐는 원하는 부분만 떼서 쓸 수 있음.
Sprite Mode 필드가 기본 Single로 되어있음. 그런데 나눠 쓸거면 Multiple 누르면 됨. 그리고 우하단 스프라이트 에디터 선택.
특별한 경우 아니면 자동 자르기 가능. slice 에서 오토매틱으로 하면 투명영역 기준으로 나뉘게 됨.
자동으로 슬라이스 된 거 선택해서 각각의 보더를 선택해서 하나를 삭제하고 다른 보더 늘려주면 됨.
다른 거는 grid by cell Size , count 가 있는데 격자 설정해서 자르는 거.
이제 스프라이트 옆의 화살표 누르면 나눠짐.

Scripts 폴더 생성.
이 Scripts 폴더에 C# 스크립트 넣어둘 것.
크리에이트-씨샵 스크립트 해서 GameManager 생성.

유니티 연동이 됐으면 어젬블리 씨샵이 연동이 되어야함.
아니면 에딧에 프리퍼런스에서 익스터널 스크립트 에디터를 강제로 비주얼 스튜디오로 바꾸고 껏다 키면 됨.

기존 씨샵과 다른 점은 유징 유니티 엔진 들어가는 것.
그리고 클래스가 규칙이 있음. 유니티에서 생성한 C# 스크립트 파일과 동일한 클래스 이름이 생성되고 클래스를 생성했을때 기본적으로 MonoBehaviour 상속받게 됨. 그러면 모노가 달린 객체만 하이어러키 상에 올라갈 수 있게 됨.
모노를 가진 객체만 정상적으로 유니티엔진이 특정 기능 사용할 수 있게 됨.


// Unity에서 스크립팅은 크게 2가지로 나뉨
// 모노를 가진 클래스, 일반 c# 클래스

// 모노를 가진 클래스 -> 일반적인 게임 객체, 유니티 기능등을 포함하는 클래스들에 사용
// 일반 c# 클래스 -> 모노는 굉장히 무겁기 때문에, 필요한 경우가 아니라면 굳이 상속받을 필요가 없음
// ex) 외부 데이터를 불러오는 클래스, 유니티의 기능을 사용하지 않는 클래스 등)

void Start() 와 void Update() 는 유니티 콜백 함수. 특정 시점에 내부에서 자동적으로 호출되는 함수.
콜백 함수를 정확히 알고 싶으면 어떻게 공부하나. 종류가 굉장히 많기 때문에 이제 항상 구글링을 해야 함.
Unity life Cycle 검색하면 유니티 매뉴얼 나옴.

게임 엔진이 바뀌거나, 새로운 프레임 워크를 접하게 되거나 하면 해당 엔진이나 프레임워크의 라이프 사이클 먼저 확인해야 함.
라이프사이클은 전체적으로 어떠한 흐름으로 실행되는지 전체 구조적 로직 이야기.

스타트는 객체 초기화 후 딱 한번 호출. 업데이트는 매 프레임마다 호출.


앞으로는 주석 잘 안쓰고 summary 쓸 것. 주석에 추가 기능 있는 것.
/// 세개 쓰면 자동으로 나올 것. 앞으로 모든 메소드 설명은 써머리로.

엔터키 누를 시 씬 전환 메소드
유니티는 씬매니저를 미리 만들어놨음.
SceneManager 작성하고 컨트롤 점 하면 using 어쩌고 나옴. 네임스페이스. 자동으로 임포트.
여기에 LoadScene()이 있음.
씬 매니저에서 인식하는 씬 종류는 파일에 빌드 셋팅 들어가면 빌드에 포함할 씬을 등록하는데 여기서 등록되지 않는 씬은 씬 매니저가 인식 못함.
사용하려는 씬은 빌드에 전부 올려야 함. 씬 폴더에서 끌어다가 놓으면 됨.
씬 옆의 넘버링은 0번 씬이 프로그램 실행했을 때 메인씬으로 실행 되고 그 외에는 프로그래머가 알아서 전환할거라 굳이 신경 쓸 필요는 없음.

스타트랑 업데이트는 사용안하면 제거.

비주얼 스튜디오에서 생성해도 상관없음. 새 파일.

타이틀 컨트롤러 가져옴. 인게임 넘어가기 전에 실행에 필요한 데이터 로드나 리소스 로드, 초기화 작업등을 수행하기 위해서.

IntroPhase 에넘 생성. 진행과정.
